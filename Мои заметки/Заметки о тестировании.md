# **Мои заметки о функциональном тестировании(JavaScript)**

Тут собраны мои небольшие замечания о простейших способах и практиках тестирования кода на языке JS.

## **Какие бывают тесты?**
------------------------------------
1. Тесты на уязвимости
2. Тесты производительности
3. Функциональные тесты. </br>

Ниже пойдет речь о 3 типе тестов. </br>
В свою очередь Функциональные тесты можно разделить на:
  1. Модульные (тестирование отдельных функций, модулей)
  2. Интеграционные (тестирование большого блока программы)
  3. Системные (тестирование программы со стороны пользователя) </br>
Лучше всего выявляют ошибки именно 3 тип тестов, но именно он самый сложный в осуществлении, так как нужно имитировать реальную работу пользователя.

### **Как делать тесты? сколько тестов нужно?** </br>
Количество тестов должно быть оптимальным. Чтобы определить эту оптимальность можно использовать следующую стратегию, по которой составлять тесты. Этапы:
(Любой тест выполняется так, как будто других тестов не существует в природе).
1. Проверяем позитивный сценарий
2. Проверяем дополнительную функциональность
3. Проверяем пограниченые случаи
</br>Исключить абсолютно все баги практически невозможно и нужно уметь вовремся остановиться. Данная система немного способствует этому, а так же помогает повысить читаемость тестов. 
------------------------------------
Теперь перейдем к способам реализации тестов. Для удобства я разделил их на 3 уровня (это не является общепринятой нормой, описание субъективного мнения)


## **Базовый (простейший) уровень**

Простейший способ тестирования не нуждается в описании. Достаточно простого примера:
```
  if (func(5) !== [1, 2]) { 
    throw new Error('Описание ошибки');
  }
```
## **Средний уровень**

Для оптимизации процесса, представленного выше можно использовать встроенный в node.js пакет assert.
Помимо оптимизации повышается удобство чтение тестов (тенденция удобства сохранится и будет расти по мере приближения к высшему уровню).
Пример использования:
```
import assert from 'assert'
assert(func(1) === 1);
const actual = func(3);
const expected = 5;
// equal - Сравнивание по ссылке
assert.equal(actual, expected);
// deepEqual для сравнения значений
// notEqual, notDeepEqual
```
Отличным дополнением является библиотека <power-assets>, которая решает основную проблему вышеперечисленных методов: <power-assets> подробно отображает где и в чем заключается ошибка.
И для решения этого вопроса можно перейти так же к следующему уровню.

## **Высший уровень**

Для качественного вывода, максимального повышения удобства чтения и организации тестов существует различные библиотеки. 
Вот некоторые из них:
1. https://www.chaijs.com/
2. https://jestjs.io/ </br>
Для более подробного углубления остановимся на последнем пакете.</br>
Для установки Jest: npm i --save-dev jest .</br>
Для интеграции с babel: npm i --save-dev babel-jest @babel/core @babel/preset-env .</br>
Так же необходимо прописать в babel.config.js:
```
module.exports = {
  presets: [
    [
      '@babel/preset-end',
      {
        targets: {
          node: 'current',
        }
      }
    ]
  ]
};
```
Тесты Jest необходимо хранить в директории __jest__ и файлы с тестами называть <name>.test.js

Рассмотрим базовые примеры тестирования:
```
test('nameTest', () => {
  expect(func(value)).toEqual(23);
});
// для запуска тестов npx jest
```
toEqual - матчер. Такое название носят методы сравнений. Таких методов достаточно много и их можно посмотреть в документации https://jestjs.io/docs/ru/expect .</br>
Примеры некоторых самых базовых матчеров:
```
toBeNull()
toBeTruthy()
toBeUndefined()
toContain() // содержит ли массив элемент
toMatch('') // Содержит ли строка подстроку
toHaveProperty('', '') // Пара ключ-значение
.not. // для отрицания матчеров
// Пример:
expect(func(value)).not.toEqual(23);
```
Хуки для использования переменных
```
let date;
beforeAll(() => date = date.Now()); // создает перед тестами
beforeEach(() => date = date.Now()); // перед каждым тестом пересоздает ее
// идея before в подготовке данных для тестирования
describe('User', () => {}); // для группировки тестов и переиспользования before
```
Чтобы узнать весь ли код покрывают тесты (достаточно 80%):
```
npx jest --coverage
```