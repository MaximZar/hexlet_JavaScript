# Небольшие замечания об асинхронном программировании на JS

Асинхронные функции сложно контролировать, так как совершенно неясно когда они выполнятся.  
Одним из решением могут стать колбэк функции, которые выполнятся после выполнения операции.  
Опять же, этот метод имеет такие недостатки как огромная вложенность, что неудобно для чтения.  
В js можно воспользоваться библиотекой async для обработки асинхронных операций.  
А так же можно использовать промисы. import { promises as fs } from 'fs';  
Промис не является результатом операции, НО это объект который выполняет отслеживание выполнение операции.  
Промисы можно продолжать с помощью простого метода .then() и then указать функцию дальнейшего действия, которая принимает в качестве аргументов данные прошлой функции.  
Соответсвенно then тоже вернет промис  
https://www.promisejs.org/   
Для возврата ошибки можно использовать метод catch, принимающий в себя колбек с параметром ошибки.  
Catch вернет промис чтобы можно было продолжить работу дальше.  
Важный момент:  
```
import { promises as fs } from 'fs';
const unionFiles = (inputPath1, inputPath2, outputPath) => {
  const result = fs.readFile(inputPath1, 'utf-8')
    .then((data1) => fs.readFile(inputPath2, 'utf-8'))
    // then ниже берется от промиса readFile
    .then((data2) => fs.writeFile(outputPath, `${<как сюда попадет data1?>}${data2}`));
  return result;
};
```  
Так же если мы попытаемся сделать нечто подобное:  
```
fs.readFile('df.js', 'utf-8').then((content) => {
  const promiseInside = fs.readFile('file2.js', 'utf-8').then(() => lalalalal);
  return promiseInside;
})
```  
Нужно понимать что в примере выше наружу вернется не promiseInside. promiseInside можно использовать лишь как контент в последующих действиях, но промис все равно вернется от первого then.  
Если нет начального действия то можно использовать заглушку, которая вернет промис Promise.resolve()  
так же в resolve можно чтото положить, что вернется далее как контент.