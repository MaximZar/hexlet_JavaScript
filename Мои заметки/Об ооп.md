### ООП  
---
парадигма, при которой строение приложения сводится к понятиям объект-экземляр.  

Об абстракциях:  
1. необходимо четко подбирать структуру данных под абстракцию. Как пример, модель чипсов Принглс, кладем сверху и забираем сверху, либо коробка с тарелками. (lifo)
2. Интерфейс - методы для взаимодействия с абстракцией
3. Уровневое проектирование - на каждом уровне есть элементарные части. И на каждом следующем уровне предыдущие уровни работают как элементарные части.
4. Связи между абстракциями(представление в виде er-модели):
    1. o2o - один с одним (пользователь и его эксперт)
    2. o2m - один со многими (урок и курс/ урок в одном курсе/ в курсе много уроков)
    3. m2m - многие со многими (один курс содержит множество пользователей и множествно пользователей содержат множество курсов)

Понятие ООП было введено Аланом Кейем. Изобретено в языке Smalltalk
Инкапсуляция = сокрытие содержимого от внешнего. Не обязательно понимается защита от воздействия, возможна просто ограниченность от внутренности абстракции.

ООП в JavaScript
1. Первый способ создания объекта
```
const make = (name, website) => ({
    name,
    website,
    getName() {
      return this.name;
    },
    getWebsite() {
      return this.website;
    },
}) // Возвращается объект (обернуто в '({})')
```
Особенности работы this:
В стрелочных функциях = нет собственного контекста. Наследуется от уровня выше. (отсутствие контекста ограничивает использование new с стрелочными функциями)
В обычных функциях = this ссылается на текущий объект, к которому привязан метод.

Бесплатная серия книг "Вы не знаете JS" https://github.com/azat-io/you-dont-know-js-ru

2. Второй способ (Правильный, истинный ооп javascript'а)
```
function Company(name, website) {
  // Такую функцию нельзя вызвать просто так, потому что тут есть this
  this.name = name;
  this.website = website;
  // Методы по прежнему определены снаружи как обычные функции
  this.getName = getName;
  this.getWebSite = getWebsite;
}
Company.prototype.push = function push(value) {
  return this.unshift(value);
}
const company = new Company('Hexlet', 'https://hexlet.io');
```
3. Третий способ, более класическое представление ооп в нынешних реалиях
```
class Company {
    email = null;
    constructor(name, email = null) {
        this.name = name;
        this.email = email;
    }
    getName() {
        return this.name;
    }
    // static getHello() {return 'Hello'} для создания статического метода
}
```